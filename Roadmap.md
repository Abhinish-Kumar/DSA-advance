## Array 

### Basic level
1. Reverse Array
2. Max and Min
3. Rotate by k step
4. Check if array is sorted
5. Star pattern
6. Second largest element without sorting
7. Remove duplicated from sorted array
8. Move Zeros to end
9. Linear Search/Sequential search in array
10. Union of two sorted array



Types of tree 

Here’s the hierarchical classification of trees in **table format**:

| **Tree Type**          | **Subcategories**                                                      | **Notes**                                                     |
|-------------------------|----------------------------------------------------------------------|---------------------------------------------------------------|
| **General Trees**       | - N-ary Tree<br>- Rooted Tree                                        | No strict limit on the number of child nodes.                |
| **Binary Trees**        | - Full Binary Tree<br>- Complete Binary Tree<br>- Perfect Binary Tree<br>- Balanced Binary Tree<br>- Degenerate (Skewed) Binary Tree<br>- Infinite Binary Tree | Each node has at most two children.                          |
| **Binary Search Tree**  | - Normal BST<br>- Balanced BST<br>&nbsp;&nbsp;- AVL Tree<br>&nbsp;&nbsp;- Red-Black Tree<br>- Splay Tree<br>- Treap | Nodes follow the order: left < root < right.                 |
| **Heap**                | - Max-Heap<br>- Min-Heap                                             | Used for priority-based operations.                          |
| **B-Trees**             | - B-Tree<br>- B+ Tree                                               | Optimized for disk-based storage and retrieval.              |
| **Trie (Prefix Tree)**  | - Standard Trie<br>- Compressed Trie<br>- Suffix Trie               | Efficient for prefix-based string searching.                 |
| **Segment Tree**        | - Static Segment Tree<br>- Dynamic Segment Tree                     | Useful for range queries and updates.                        |
| **Fenwick Tree**        | - Binary Indexed Tree                                               | Efficient for prefix sum calculations.                       |
| **Suffix Tree**         | - None                                                              | Used for fast pattern matching in strings.                   |
| **Spanning Tree**       | - Minimum Spanning Tree<br>&nbsp;&nbsp;- Kruskal’s Algorithm<br>&nbsp;&nbsp;- Prim’s Algorithm<br>- Maximum Spanning Tree | Covers all vertices of a graph while minimizing/maximizing edge weights. |

Let me know if you’d like a detailed explanation for any specific tree type!
